package chess;

import java.util.ArrayList;
import java.util.Collections;

public class ChessModel implements IChessModel {

	private IChessPiece[][] board;
	private Player player;
	private final int BOARD_SIZE = 8;
	private boolean firstMove;
	private int numMoves;	
	private ArrayList <Move> randomMoves;
	private Move bestMove;
	private Move tempMove;
	private Move lastMove;
	private IChessPiece[][] tempBoard;
	
	private boolean AIEnabled;

	Player p;

	//	private int moveCount;

	private ArrayList <IChessPiece> whitePieces;
	private ArrayList <IChessPiece> blackPieces;

	public ChessModel() {		
		reset();
		setAIEnabled(true);
	}	

	public void reset() {
		board = new IChessPiece[BOARD_SIZE][BOARD_SIZE];
		numMoves = 0;
		tempMove = null;

		p = Player.BLACK;
		//		moveCount = 0;

		tempBoard = new IChessPiece[BOARD_SIZE][BOARD_SIZE];

		whitePieces = new ArrayList<IChessPiece>();
		blackPieces = new ArrayList<IChessPiece>();

		player = Player.BLACK; // setting the AI to black
		board[0][0] = new Rook(player);
		board[0][1] = new Knight(player);
		board[0][2] = new Bishop(player);
		board[0][3] = new Queen(player);
		board[0][4] = new King(player);
		board[0][5] = new Bishop(player);
		board[0][6] = new Knight(player);
		board[0][7] = new Rook(player);

		for(int col = 0; col < 8; col++)
			board[1][col] = new Pawn(player);

		player = Player.WHITE;
		board[7][0] = new Rook(player);
		board[7][1] = new Knight(player);
		board[7][2] = new Bishop(player);
		board[7][3] = new Queen(player);
		board[7][4] = new King(player);
		board[7][5] = new Bishop(player);
		board[7][6] = new Knight(player);
		board[7][7] = new Rook(player);

		for(int col = 0; col < 8; col++)
			board[6][col] = new Pawn(player);

		randomMoves = new ArrayList<Move>();
		randomMoves.add(new Move(0, 1, 2, 0));
		randomMoves.add(new Move(1, 1, 3, 1));
		randomMoves.add(new Move(1, 3, 2, 3));
		randomMoves.add(new Move(0, 6, 2, 5));
		randomMoves.add(new Move(1, 2, 3, 2));
		randomMoves.add(new Move(1, 4, 2, 4));
		randomMoves.add(new Move(1, 6, 2, 6));
		randomMoves.add(new Move(1, 7, 3, 7));
		Collections.shuffle(randomMoves);

		setFirstMove(true);
	}

	public boolean isCellOccupied(IChessPiece temp){
		if (temp != null)
			return true;
		return false;
	}

	public boolean isFirstMove() {
		return firstMove;
	}

	public void setFirstMove(boolean firstMove) {
		this.firstMove = firstMove;
	}
	
	public boolean isAIEnabled() {
		return AIEnabled;
	}

	public void setAIEnabled(boolean aIEnabled) {
		AIEnabled = aIEnabled;
	}

	public boolean isValidMove(Move move) {

		//duplicateBoard(board);

		if (board[move.fromRow][move.fromColumn].player() != player) {
			throw new IllegalPlayer();
		}

		if (!castling(move)) {

			if (board[move.fromRow][move.fromColumn].isValidMove(move, board)) {
				return true;
			}
			else 
				throw new InvalidMove();
		}
		else
			return false;
	}

	public void promotion(Move move){  			//take out used pieces
		int y = 0;
		IChessPiece tempPiece = null;
		if (tempBoard[move.fromRow][move.fromColumn].player() == Player.WHITE){
			if ( tempBoard[move.fromRow][move.fromColumn].type().equals("Pawn")){
				for (int x = 0; x < whitePieces.size(); x++){
					if (whitePieces.get(x) != null && !whitePieces.get(x).type().equals("Pawn")){
						if (whitePieces.get(x).getPieceWorth() >= y){
							y = whitePieces.get(x).getPieceWorth();
							tempPiece = whitePieces.get(x);
						}
					}
				}
			}
			board[move.toRow][move.toColumn] = tempPiece;
		}
		else {
			y = 0;
			tempPiece = null;
			if (tempBoard[move.fromRow][move.fromColumn].player() == Player.BLACK){
				if (tempBoard[move.fromRow][move.fromColumn].type().equals("Pawn")){
					for (int x = 0; x < blackPieces.size(); x++){
						if (blackPieces.get(x) != null && !blackPieces.get(x).type().equals("Pawn") ){
							if (blackPieces.get(x).getPieceWorth() >= y){
								y = blackPieces.get(x).getPieceWorth();
								tempPiece = blackPieces.get(x) ;
							}
						}
					}
				}
			}
			board[move.toRow][move.toColumn] = tempPiece;
		}
	}

	public void move(Move move) {

		IChessPiece temp1 = board[move.toRow][move.toColumn];



		if (temp1 != null){
			if(temp1.player() == Player.WHITE) {
				whitePieces.add(temp1);
			}
			else {
				blackPieces.add(temp1);
			}
		}

		if (pieceAt(move.fromRow, move.fromColumn) != null 
				&& pieceAt(move.fromRow, move.fromColumn).type().equals("Pawn") 
				&& move.toRow == 0 || move.toRow == 7 && player == pieceAt(move.fromRow, move.fromColumn).player()){
			promotion(move);
			board[move.fromRow][move.fromColumn] = null;

			if (pieceAt(move.toRow, move.toColumn) == null || pieceAt(move.toRow, move.toColumn).type().equals("Pawn")) {

				board[move.toRow][move.toColumn] = new Queen(player);
				player = player.next();
				throw new NoDeadPieces();
			}
			player = player.next();
		}
		else
		{

			IChessPiece temp = board[move.fromRow][move.fromColumn];
			board[move.toRow][move.toColumn] = board[move.fromRow][move.fromColumn];
			board[move.fromRow][move.fromColumn] = null;
			boolean black = inCheck(Player.BLACK);
			boolean white = inCheck(Player.WHITE);
			boolean blackCM = isComplete(Player.BLACK);
			boolean whiteCM = isComplete(Player.WHITE);

			if (whiteCM || blackCM){
				if (player == Player.WHITE && whiteCM) {
					board[move.fromRow][move.fromColumn] = temp;
					board[move.toRow][move.toColumn] = temp1;
				}
				if (player == Player.BLACK && blackCM) {
					board[move.fromRow][move.fromColumn] = temp;
					board[move.toRow][move.toColumn] = temp1;
				} 
				if (player == Player.WHITE && blackCM) {
					board[move.fromRow][move.fromColumn] = null;
					board[move.toRow][move.toColumn] = temp;
					player = player.next(); 
					throw new CheckMate();
				}
				if (player == Player.BLACK && whiteCM) {
					board[move.fromRow][move.fromColumn] = null;
					board[move.toRow][move.toColumn] = temp;
					player = player.next();
					throw new CheckMate();
				}
			}

			else {

				if (player == Player.WHITE && white) {
					board[move.fromRow][move.fromColumn] = temp;
					board[move.toRow][move.toColumn] = temp1;
				}
				else if (player == Player.BLACK && black) {
					board[move.fromRow][move.fromColumn] = temp;
					board[move.toRow][move.toColumn] = temp1;
				} 
				else {
					if (player == Player.WHITE && black) {
						board[move.fromRow][move.fromColumn] = null;
						board[move.toRow][move.toColumn] = temp;
						player = player.next(); 
						throw new Check();
					}
					if (player == Player.BLACK && white) {
						board[move.fromRow][move.fromColumn] = null;
						board[move.toRow][move.toColumn] = temp;
						player = player.next();
						throw new Check();
					}
					if (!black && !white) {
						board[move.toRow][move.toColumn] = temp;
						player = player.next();
					}
				}
			}
		}
	}


	public boolean inCheck(Player p) {

		duplicateBoard(board);

		for (int row = 0; row < BOARD_SIZE; row++)
			for (int col = 0; col < BOARD_SIZE; col++) {
				if (tempBoard[row][col] != null) 
					if (tempBoard[row][col].player() != p) {
						for (int r = 0; r < BOARD_SIZE; r++)
							for (int c = 0; c < BOARD_SIZE; c++) {
								Move temp = new Move(row, col, r, c);
								if (isValidMoveAI(temp) && board[r][c] != null)
									if (tempBoard[r][c].player() == p && tempBoard[r][c].type().equals("King"))
										return true;
							}
					}
			}
		return false;
	}


	public boolean inCheck1(Player p) {

		for (int row = 0; row < BOARD_SIZE; row++)
			for (int col = 0; col < BOARD_SIZE; col++) {
				if (tempBoard[row][col] != null) 
					if (tempBoard[row][col].player() != p) {
						for (int r = 0; r < BOARD_SIZE; r++)
							for (int c = 0; c < BOARD_SIZE; c++) {
								Move temp = new Move(row, col, r, c);
								if (isValidMoveAI(temp) && tempBoard[r][c] != null)
									if (tempBoard[r][c].player() == p && tempBoard[r][c].type().equals("King"))
										return true;
							}
					}
			}
		return false;
	}

	public boolean isComplete(Player p) {

		duplicateBoard(board);

		for (int row = 0; row < BOARD_SIZE; row++)
			for (int col = 0; col < BOARD_SIZE; col++) {
				if (tempBoard[row][col] != null) 
					if (tempBoard[row][col].player() == p) {
						for (int r = 0; r < BOARD_SIZE; r++)
							for (int c = 0; c < BOARD_SIZE; c++) {
								Move temp = new Move(row, col, r, c);
								IChessPiece tempPiece = tempBoard[row][col];
								IChessPiece tempPiece1 = null;
								if ( tempBoard[r][c] != null)
									tempPiece1 = tempBoard[r][c];
								if (isValidMoveAI(temp) ) {
									tempBoard[row][col] = null;
									tempBoard[r][c] = tempPiece;

									if (!inCheck1(p)){
										tempBoard[row][col] = tempPiece;
										tempBoard[r][c] = tempPiece1;
										return false;
									}
								}
								tempBoard[row][col] = tempPiece;
								tempBoard[r][c] = tempPiece1;
							}

					}
			}
		return true;
	}

	public void duplicateBoard(IChessPiece[][] newBoard) {

		tempBoard = new IChessPiece[BOARD_SIZE][BOARD_SIZE];

		for (int row = 0; row < BOARD_SIZE; row++)
			for (int col = 0; col < BOARD_SIZE; col++) {
				if (board[row][col] != null ){
					if (newBoard[row][col].type().equals("Pawn") && newBoard[row][col].player() == Player.WHITE){
						tempBoard[row][col] = new Pawn(Player.WHITE);
					}
					else if (newBoard[row][col].type().equals("Pawn"))
						tempBoard[row][col] = new Pawn(Player.BLACK);

					if (newBoard[row][col].type().equals("Rook") && newBoard[row][col].player() == Player.WHITE)
						tempBoard[row][col] = new Rook(Player.WHITE);
					else if (newBoard[row][col].type().equals("Rook"))
						tempBoard[row][col] = new Rook(Player.BLACK);

					if (newBoard[row][col].type().equals("Bishop") && newBoard[row][col].player() == Player.WHITE)
						tempBoard[row][col] = new Bishop(Player.WHITE);
					else if (newBoard[row][col].type().equals("Bishop"))
						tempBoard[row][col] = new Bishop(Player.BLACK);

					if (newBoard[row][col].type().equals("Knight") && newBoard[row][col].player() == Player.WHITE)
						tempBoard[row][col] = new Knight(Player.WHITE);
					else if (newBoard[row][col].type().equals("Knight"))
						tempBoard[row][col] = new Knight(Player.BLACK);

					if (newBoard[row][col].type().equals("King") && newBoard[row][col].player() == Player.WHITE)
						tempBoard[row][col] = new King(Player.WHITE);
					else if (newBoard[row][col].type().equals("King"))
						tempBoard[row][col] = new King(Player.BLACK);

					if (newBoard[row][col].type().equals("Queen") && newBoard[row][col].player() == Player.WHITE)
						tempBoard[row][col] = new Queen(Player.WHITE);
					else if (newBoard[row][col].type().equals("Queen"))
						tempBoard[row][col] = new Queen(Player.BLACK);
				}
			}
	}


	public Player currentPlayer() {
		return player;
	}

	public int numRows() {
		return BOARD_SIZE;
	}

	public int numColumns() {
		return BOARD_SIZE;
	}

	public IChessPiece pieceAt(int row, int col) {
		return board[row][col];
	}

	public Move ChessAIMove() {
		if (Player.BLACK == player) {

			duplicateBoard(board);

			int moveValue = 0;
			//			moveCount = 0;
			//bestMove = null;


			if (inCheck(Player.BLACK)){
				System.out.println("YAY");
				for (int row = 0; row < BOARD_SIZE; row++)
					for (int col = 0; col < BOARD_SIZE; col++) {
						System.out.println("black in check");
						if (tempBoard[row][col] != null) 
							if (tempBoard[row][col].player() == Player.BLACK) {
								for (int r = 0; r < BOARD_SIZE; r++)
									for (int c = 0; c < BOARD_SIZE; c++) {
										Move temp = new Move(row, col, r, c);
										IChessPiece tempPiece = tempBoard[row][col];
										IChessPiece tempPiece1 = null;
										if ( tempBoard[r][c] != null)
											tempPiece1 = tempBoard[r][c];
										if (isValidMoveAI(temp) ) {
											tempBoard[r][c] = tempPiece;
											tempBoard[row][col] = null;

											if (!inCheck1(Player.BLACK)){
												tempBoard[row][col] = tempPiece;
												tempBoard[r][c] = tempPiece1;
												//													tempMove = temp;// changed to tempMove instead of bestMove
												return temp;
											}
										}
										tempBoard[row][col] = tempPiece;
										tempBoard[r][c] = tempPiece1;
									}

							}
					}
			}

			else {

				if (numMoves < 4) {
					for (int i = numMoves; i < randomMoves.size(); i++)
						if(isValidMoveAI(randomMoves.get(i))) {
							bestMove = randomMoves.get(i);
							lastMove = bestMove;
							numMoves++;
							return bestMove;
						}			
				}


				else {
					for (int row = 0; row < BOARD_SIZE; row++)
						for (int col = 0; col < BOARD_SIZE; col++) { 
							if (tempBoard[row][col] != null)  
								if (tempBoard[row][col].player() == Player.BLACK){  
									int temp = ChessAI(tempBoard[row][col]);          //send to ChessAI
									if (temp >= moveValue) {
										moveValue = temp;
										bestMove = tempMove;
									}
								}
						}
					lastMove = bestMove;
					return bestMove;
				}
			}
		}
		return null;
	}

	public int ChessAI(IChessPiece AIBoard) {

		int moveValue = 0;
		int tempValue = 0;

		for (int row = 0; row < BOARD_SIZE; row++) {
			for (int col = 0; col < BOARD_SIZE; col++) {
				if (tempBoard[row][col] == AIBoard)
					for (int r = 0; r < BOARD_SIZE; r++) {
						for (int c = 0; c < BOARD_SIZE; c++) {
							if (r == lastMove.fromRow && c == lastMove.fromColumn) 		//use lastMove
								break;
							Move temp = new Move(row, col, r, c);
							if (isValidMoveAI(temp)) {

								if (tempBoard[r][c] != null && tempBoard[r][c].type().equals("Pawn") && 
										tempBoard[row][col].type().equals("Pawn")) //if pawn to pawn make move 7
									moveValue = 7;
								else if (tempBoard[r][c] != null && tempBoard[r][c].type().equals(tempBoard[row][col].type()))
									moveValue = AIBoard.getPieceWorth() * 2; //if same piece *2
								else if(tempBoard[r][c] != null)
									moveValue = AIBoard.getPieceWorth() + tempBoard[r][c].getPieceWorth(); // random to random add them
								else
									moveValue = 1; //empty 'to' cell just make it 1

								if (moveValue > tempValue) {
									tempValue = moveValue;
									tempMove = temp;
								}
							}
						}
					}
			}
		}
		return tempValue;
	}


	public boolean castling(Move move) {

		duplicateBoard(board);

		if(player == Player.WHITE) {
			if(pieceAt(move.fromRow, move.fromColumn).type().equals("King"))
				if (((King)board[move.fromRow][move.fromColumn]).isCastlingValid())
					if (move.toColumn == 2 && pieceAt(7, 0) instanceof Rook) {
						if (((Rook)pieceAt(7, 0)).isCastlingValid())
							if(pieceAt(7, 1) == null && pieceAt(7, 2) == null && pieceAt(7,3) == null) {

								Move temp = new Move(7, 4, 7, 3);
								if (isValidMoveAI(temp)) {

									board[7][3] = board[7][4];
									board[7][4] = null;

									if (!inCheck1(Player.WHITE)) {

										Move temp1 = new Move(7, 3, 7, 2);
										if (isValidMoveAI(temp1)){

											board[7][2] = board[7][3];
											board[7][3] = null;

											if (!inCheck1(Player.WHITE)) {

												board[7][3] = tempBoard[7][0];
												board[7][0] = null; //setting rook to null
												board[7][4] = null; //setting king to null
												player = player.next();
												return true;
											}
										}
									}

									board[7][4] = board[7][2];
									board[7][2] = null;
									board[7][0] = board[7][3];
									board[7][3] = null;
								}
							}
					}
					else 
						if (move.toColumn == 6 && pieceAt(7, 7) instanceof Rook) {
							if (((Rook)pieceAt(7, 7)).isCastlingValid())
								if(pieceAt(7, 5) == null && pieceAt(7, 6) == null) {

									Move temp = new Move(7, 4, 7, 5);
									if (isValidMoveAI(temp)) {

										board[7][5] = board[7][4];
										board[7][4] = null;

										if (!inCheck1(Player.WHITE)) {

											Move temp1 = new Move(7, 5, 7, 6);
											if (isValidMoveAI(temp1) ){

												board[7][6] = board[7][5];
												board[7][5] = null;
												board[7][5] = tempBoard[7][7];
												board[7][7] = null; //setting rook to null
												board[7][4] = null; //setting king to null
												if (!inCheck1(Player.WHITE)) {
													player = player.next();
													return true;
												}


											}
											board[7][4] = board[7][6];
											board[7][6] = null;
											board[7][7] = board[7][5];
											board[7][5] = null;
										}
										board[7][4] = board[7][5];
										board[7][5] = null;
									}
								}
						}
		}
		else 
			if(pieceAt(move.fromRow, move.fromColumn).type().equals("King"))
				if (((King)board[move.fromRow][move.fromColumn]).isCastlingValid())
					if (move.toColumn == 2 && pieceAt(0, 0) instanceof Rook) {
						if (((Rook)pieceAt(0, 0)).isCastlingValid())
							if(pieceAt(0, 1) == null && pieceAt(0, 2) == null && pieceAt(0,3) == null) {

								Move temp = new Move(0, 4, 0, 3);
								isValidMove(temp);

								board[0][3] = board[0][4];
								board[0][4] = null;

								if (!inCheck1(Player.BLACK)) {

									Move temp1 = new Move(0, 3, 0, 2);
									isValidMove(temp1);

									board[0][2] = board[0][3];
									board[0][3] = null;

									if (!inCheck1(Player.BLACK)) {

										board[0][3] = tempBoard[0][0];
										board[0][0] = null; //setting rook to null
										board[0][4] = null; //setting king to null
										player = player.next();
										return true;
									}

								}


							}
					}
					else 
						if (move.toColumn == 6 && pieceAt(0, 7) instanceof Rook) {
							if (((Rook)pieceAt(0, 7)).isCastlingValid())
								if(pieceAt(0, 5) == null && pieceAt(0, 6) == null) {

									Move temp = new Move(0, 4, 0, 5);
									isValidMove(temp);

									board[0][5] = board[0][4];
									board[0][4] = null;

									if (!inCheck1(Player.BLACK)) {

										Move temp1 = new Move(0, 5, 0, 6);
										isValidMove(temp1);

										board[0][6] = board[0][5];
										board[0][5] = null;

										if (!inCheck1(Player.BLACK)) {

											board[0][5] = tempBoard[0][7];
											board[0][7] = null; //setting rook to null
											board[0][4] = null; //setting king to null
											player = player.next();
											return true;
										}

									}
								}
						}

		return false;
	}

	public boolean isValidMoveAI(Move move) {

		if ((tempBoard[move.fromRow][move.fromColumn] != null))
			if (tempBoard[move.fromRow][move.fromColumn].isValidMove(move, tempBoard))
				return true;

		if (tempBoard[move.fromRow][move.fromColumn] == null)
			return false;

		return false;
	}

	public Move getOutOfCheck() {

		for (int row = 0; row < BOARD_SIZE; row++)
			for (int col = 0; col < BOARD_SIZE; col++) {
				if (tempBoard[row][col] != null) 
					if (tempBoard[row][col].player() != Player.BLACK) {
						for (int r = 0; r < BOARD_SIZE; r++)
							for (int c = 0; c < BOARD_SIZE; c++) {
								Move temp = new Move(row, col, r, c);
								if (isValidMoveAI(temp)) {
									tempBoard[r][c] = tempBoard[row][col];
									IChessPiece temp1 = tempBoard[row][col];
									tempBoard[row][col] = null;

									if (!inCheck(Player.BLACK)) {
										tempMove = temp;
										tempBoard[r][c] = null;
										tempBoard[row][col] = temp1;
									}
								}

							}
					}
			}
		return tempMove;

	}

	public void setAIMove(Move move) {
		board[move.toRow][move.toColumn] = board[move.fromRow][move.fromColumn];
		board[move.fromRow][move.fromColumn] = null;
		player = player.next();
	}
}
