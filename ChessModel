
import java.util.ArrayList;
import java.util.Collections;

/*****************************************************************************
 * This class creates the chess game and is brains behind the GUI. every
 * decision is made in this class.
 * 
 * @author Nathan Kelderman and Matt Shampine
 * @version 1.0
 ***************************************************************************/
public class ChessModel implements IChessModel {

	/** a double array that stores all the pieces at their location on the 
	 * board */
	private IChessPiece[][] board;

	/** stores the current player */
	private Player player;

	/** sets board size to 8 */
	private final int BOARD_SIZE = 8;

	/** stores if it is the first click or not */
	private boolean firstClick;

	/** stores the number of moves the AI has done for random moves */
	private int numMoves;

	/** stores 8 moves for the AI to use randomly */
	private ArrayList<Move> randomMoves;

	/** stores the best move for the AI to use for the next move */
	private Move bestMove;

	/** stores a possibly best move for the AI which is used to check against 
	 * the current best move */
	private Move possibleMove;

	/** stores the last move the AI did so it doesn't move back to that 
	 * spot */
	private Move lastMove;

	/** used to copy the current board so it can be manipulated without 
	 * moving pieces on the actual board*/
	private IChessPiece[][] tempBoard;

	/** stores whether or not the AI is turned on or off */
	private boolean AIEnabled;

	/** stores all the dead white pieces */
	private ArrayList<IChessPiece> whitePieces;

	/** stores all the dead black pieces */
	private ArrayList<IChessPiece> blackPieces;

	/*************************************************************************
	 * The constructor resets the board to the default chess board and sets
	 * the AI to be on.
	 * 
	 ***********************************************************************/
	public ChessModel() {
		reset();
		setAIEnabled(true);
	}


	/*************************************************************************
	 * The reset method sets the board to a default board with all the pieces
	 * positions set to the normal spots on the board according to chess 
	 * rules. It also duplicates the board to the tempBoard in case a later
	 * method uses the tempBoard.
	 * 
	 ***********************************************************************/
	public void reset() {
		board = new IChessPiece[BOARD_SIZE][BOARD_SIZE];
		numMoves = 0;
		possibleMove = null;

		tempBoard = new IChessPiece[BOARD_SIZE][BOARD_SIZE];

		whitePieces = new ArrayList<IChessPiece>();
		blackPieces = new ArrayList<IChessPiece>();

		player = Player.BLACK; // setting the AI to black
		board[0][0] = new Rook(player);
		board[0][1] = new Knight(player);
		board[0][2] = new Bishop(player);
		board[0][3] = new Queen(player);
		board[0][4] = new King(player);
		board[0][5] = new Bishop(player);
		board[0][6] = new Knight(player);
		board[0][7] = new Rook(player);

		for (int col = 0; col < 8; col++)
			board[1][col] = new Pawn(player);

		player = Player.WHITE;
		board[7][0] = new Rook(player);
		board[7][1] = new Knight(player);
		board[7][2] = new Bishop(player);
		board[7][3] = new Queen(player);
		board[7][4] = new King(player);
		board[7][5] = new Bishop(player);
		board[7][6] = new Knight(player);
		board[7][7] = new Rook(player);

		for (int col = 0; col < 8; col++)
			board[6][col] = new Pawn(player);

		randomMoves = new ArrayList<Move>();
		randomMoves.add(new Move(0, 1, 2, 0));
		randomMoves.add(new Move(1, 1, 3, 1));
		randomMoves.add(new Move(1, 3, 2, 3));
		randomMoves.add(new Move(0, 6, 2, 5));
		randomMoves.add(new Move(1, 2, 3, 2));
		randomMoves.add(new Move(1, 4, 2, 4));
		randomMoves.add(new Move(1, 6, 2, 6));
		randomMoves.add(new Move(1, 7, 3, 7));
		Collections.shuffle(randomMoves);

		setFirstClick(true);
		duplicateBoard(board);
	}

	/*************************************************************************
	 * Checks to see if the spot on the cell if occupied.
	 * 
	 * @param temp stores a piece
	 * @return returns true if cell contains a piece and false if not
	 ************************************************************************/
	public boolean isCellOccupied(IChessPiece temp) {
		if (temp != null)
			return true;
		return false;
	}

	/*************************************************************************
	 * Getter for checking if it is the first click.
	 * 
	 * @return firstClick returns if it is the first click or not
	 ************************************************************************/
	public boolean isFirstClick() {
		return firstClick;
	}

	/*************************************************************************
	 * Setter for declaring if it is the first click or not.
	 * 
	 * @param firstClick 
	 ************************************************************************/
	public void setFirstClick(boolean firstClick) {
		this.firstClick = firstClick;
	}

	/*************************************************************************
	 * Getter for AIEnabled.
	 * 
	 * @return returns if AI is turned on or not
	 ************************************************************************/
	public boolean isAIEnabled() {
		return AIEnabled;
	}

	/*************************************************************************
	 * Setter for enabling or disabling the AI.
	 * 
	 * @param aIEnabled sets the AI to be enabled or disabled
	 ************************************************************************/
	public void setAIEnabled(boolean AIEnabled) {
		this.AIEnabled = AIEnabled;
	}

	/*************************************************************************
	 * Checks if the inputed move is a valid move.
	 * 
	 * @param move receives a move to check if it is valid
	 * @see IChessPiece#isValidMove(Move move)
	 ************************************************************************/
	public boolean isValidMove(Move move) {
		if (board[move.fromRow][move.fromColumn].player() != player) {
			throw new IllegalPlayer();
		}
		if (!castling(move)) {
			if (board[move.fromRow][move.fromColumn].isValidMove(move, board))
				return true;
			else
				throw new InvalidMove();
		} else
			return false;
	}

	/*************************************************************************
	 * Promotes a pawn to the highest value piece that is dead and removes 
	 * that piece from the dead pieces array.
	 * 
	 * @param move takes in a move so it can check if the fromRow and 
	 * fromColumn is a pawn and if it is White or Black
	 ************************************************************************/
	public void promotion(Move move) { // take out used pieces
		int y = 0;
		int z = 0;
		IChessPiece tempPiece = null;
		if (tempBoard[move.fromRow][move.fromColumn].player() ==
				Player.WHITE) {
			if (tempBoard[move.fromRow][move.fromColumn].type().
					equals("Pawn")) {
				for (int x = 0; x < whitePieces.size(); x++) {
					if (whitePieces.get(x) != null && 
							!whitePieces.get(x).type().equals("Pawn")) {
						if (whitePieces.get(x).getPieceWorth() >= y) {
							y = whitePieces.get(x).getPieceWorth();
							tempPiece = whitePieces.get(x);
							z = x;
						}
					}
				}
			}
			board[move.toRow][move.toColumn] = tempPiece;
			if (whitePieces.size() != 0)
				whitePieces.remove(z);
		} else {
			y = 0;
			tempPiece = null;
			if (tempBoard[move.fromRow][move.fromColumn].player() == 
					Player.BLACK) {
				if (tempBoard[move.fromRow][move.fromColumn].type().
						equals("Pawn")) {
					for (int x = 0; x < blackPieces.size(); x++) {
						if (blackPieces.get(x) != null && !blackPieces.get(x).
								type().equals("Pawn")) {
							if (blackPieces.get(x).getPieceWorth() >= y) {
								y = blackPieces.get(x).getPieceWorth();
								tempPiece = blackPieces.get(x);
								z = x;
							}
						}
					}
				}
			}
			board[move.toRow][move.toColumn] = tempPiece;
			if (blackPieces.size() != 0)
				blackPieces.remove(z);
		}
	}

	/*************************************************************************
	 * Moves the piece on the board to the new spot if all the requirements
	 * have been met and promotes the pawn if necessary and stores the
	 * piece taken out (if a piece is taken out) into the arrayList of dead
	 * pieces.
	 * 
	 * @param move is the move that is to be made
	 * @see IChessModel#move(Move)
	 ************************************************************************/
	public void move(Move move) {

		IChessPiece temp1 = board[move.toRow][move.toColumn];

		if (temp1 != null) {
			if (temp1.player() == Player.WHITE) {
				whitePieces.add(temp1);
			} else {
				blackPieces.add(temp1);
			}
		}
		
		if (pieceAt(move.fromRow, move.fromColumn) != null
				&& pieceAt(move.fromRow, move.fromColumn).type().
				equals("Pawn") && ((move.toRow == 0 && 
				board[move.fromRow][move.fromColumn].player() == Player.WHITE)
				|| (move.toRow == 7 && board[move.fromRow][move.fromColumn].
				player() == Player.BLACK))
				&& player == pieceAt(move.fromRow, move.fromColumn).player()){
			promotion(move);
			board[move.fromRow][move.fromColumn] = null;
			if (pieceAt(move.toRow, move.toColumn) == null
					|| pieceAt(move.toRow, move.toColumn).
					type().equals("Pawn")) {
				board[move.toRow][move.toColumn] = new Queen(player);
				player = player.next();
				if ((player == Player.WHITE && inCheck(Player.WHITE))
						|| (player == Player.BLACK && 
						inCheck(Player.BLACK))) {
					if ((player == Player.WHITE && isComplete(Player.WHITE))
							|| (player == Player.BLACK && 
							isComplete(Player.BLACK))) {
						throw new NoDeadPiecesInCheckMate();
					} else
						throw new NoDeadPiecesInCheck();
				}
				throw new NoDeadPieces();
			}
			player = player.next();
			if ((player == Player.WHITE && inCheck(Player.WHITE))
					|| (player == Player.BLACK && inCheck(Player.BLACK))) {
				if ((player == Player.WHITE && isComplete(Player.WHITE))
						|| (player == Player.BLACK && 
						isComplete(Player.BLACK))) {
					throw new CheckMate();
				} else
					throw new Check();
			}
		} else {
			IChessPiece temp = board[move.fromRow][move.fromColumn];
			board[move.toRow][move.toColumn] = 
					board[move.fromRow][move.fromColumn];
			board[move.fromRow][move.fromColumn] = null;
			boolean black = inCheck(Player.BLACK);
			boolean white = inCheck(Player.WHITE);
			boolean blackCM = isComplete(Player.BLACK);
			boolean whiteCM = isComplete(Player.WHITE);
			if (whiteCM || blackCM) {
				if (player == Player.WHITE && whiteCM) {
					board[move.fromRow][move.fromColumn] = temp;
					board[move.toRow][move.toColumn] = temp1;
				}
				if (player == Player.BLACK && blackCM) {
					board[move.fromRow][move.fromColumn] = temp;
					board[move.toRow][move.toColumn] = temp1;
				}
				if (player == Player.WHITE && blackCM) {
					board[move.fromRow][move.fromColumn] = null;
					board[move.toRow][move.toColumn] = temp;
					player = player.next();
					throw new CheckMate();
				}
				if (player == Player.BLACK && whiteCM) {
					board[move.fromRow][move.fromColumn] = null;
					board[move.toRow][move.toColumn] = temp;
					player = player.next();
					throw new CheckMate();
				}
			}
			else {

				if (player == Player.WHITE && white) {
					board[move.fromRow][move.fromColumn] = temp;
					board[move.toRow][move.toColumn] = temp1;
				} else if (player == Player.BLACK && black) {
					board[move.fromRow][move.fromColumn] = temp;
					board[move.toRow][move.toColumn] = temp1;
				} else {
					if (player == Player.WHITE && black) {
						board[move.fromRow][move.fromColumn] = null;
						board[move.toRow][move.toColumn] = temp;
						player = player.next();
						throw new Check();
					}
					if (player == Player.BLACK && white) {
						board[move.fromRow][move.fromColumn] = null;
						board[move.toRow][move.toColumn] = temp;
						player = player.next();
						throw new Check();
					}
					if (!black && !white) {
						board[move.toRow][move.toColumn] = temp;
						player = player.next();
					}
				}
			}
		}
	}

	/************************************************************************
	 * Checks to see if Player p is in check. Cycles through all the enemy 
	 * pieces and if on of them can hit the friendly king then Player p is in
	 * check.
	 * 
	 * @param p is the player that is being checked if they are in check
	 * @return returns true if in check and false if not
	 * @see IChessModel#inCheck(Player)
	 ************************************************************************/
	public boolean inCheck(Player p) {

		duplicateBoard(board);

		for (int row = 0; row < BOARD_SIZE; row++)
			for (int col = 0; col < BOARD_SIZE; col++) {
				if (tempBoard[row][col] != null)
					if (tempBoard[row][col].player() != p) {
						for (int r = 0; r < BOARD_SIZE; r++)
							for (int c = 0; c < BOARD_SIZE; c++) {
								Move temp = new Move(row, col, r, c);
								if (isValidMoveAI(temp) && board[r][c] != 
										null)
									if (tempBoard[r][c].player() == p && 
									tempBoard[r][c].type().equals("King"))
										return true;
							}
					}
			}
		return false;
	}

	/*************************************************************************
	 * This inCheck method is used by the isComplete method which moves pieces
	 * on the tempBoard so we don't want to duplicate the board again like the
	 * other inCheck method does.
	 * 
	 * @param p is the player being checked if they are in check or not
	 * @return returns true if in check or false if not
	 ************************************************************************/
	public boolean tempBoardInCheck(Player p) {

		for (int row = 0; row < BOARD_SIZE; row++)
			for (int col = 0; col < BOARD_SIZE; col++) {
				if (tempBoard[row][col] != null)
					if (tempBoard[row][col].player() != p) {
						for (int r = 0; r < BOARD_SIZE; r++)
							for (int c = 0; c < BOARD_SIZE; c++) {
								Move temp = new Move(row, col, r, c);
								if (isValidMoveAI(temp) && tempBoard[r][c] != 
										null)
									if (tempBoard[r][c].player() == p && 
									tempBoard[r][c].type().equals("King"))
										return true;
							}
					}
			}
		return false;
	}

	/*************************************************************************
	 * This method cycles through all of the Player p pieces and moves all of
	 * them to all of its possible move locations and checks if the king is 
	 * still in check. If the king is still in check after all pieces have
	 * been moved then the king is in checkmate otherwise if there is a 
	 * piece that can be moved to take the king out of check then the king
	 * is not in checkmate.
	 * 
	 * @param p is the player being checked if they are in check
	 * @return returns true if king is in checkmate and false if not
	 * @see IChessModel#isComplete(Player)
	 ************************************************************************/
	public boolean isComplete(Player p) {

		duplicateBoard(board);

		for (int row = 0; row < BOARD_SIZE; row++)
			for (int col = 0; col < BOARD_SIZE; col++) {
				if (tempBoard[row][col] != null)
					if (tempBoard[row][col].player() == p) {
						for (int r = 0; r < BOARD_SIZE; r++)
							for (int c = 0; c < BOARD_SIZE; c++) {
								Move temp = new Move(row, col, r, c);
								IChessPiece tempPiece = tempBoard[row][col];
								IChessPiece tempPiece1 = null;
								if (tempBoard[r][c] != null)
									tempPiece1 = tempBoard[r][c];
								if (isValidMoveAI(temp)) {
									tempBoard[row][col] = null;
									tempBoard[r][c] = tempPiece;
									if (!tempBoardInCheck(p)) {
										tempBoard[row][col] = tempPiece;
										tempBoard[r][c] = tempPiece1;
										return false;
									}
								}
								tempBoard[row][col] = tempPiece;
								tempBoard[r][c] = tempPiece1;
							}

					}
			}
		return true;
	}

	/*************************************************************************
	 * Creates a new board with the pieces at the same spot as the current 
	 * board so the program can manipulate the tempBoard without changing
	 * anything on the current board.
	 * 
	 * @param newBoard is the board that tempBoard is copying
	 ************************************************************************/
	public void duplicateBoard(IChessPiece[][] newBoard) {

		tempBoard = new IChessPiece[BOARD_SIZE][BOARD_SIZE];

		for (int row = 0; row < BOARD_SIZE; row++)
			for (int col = 0; col < BOARD_SIZE; col++) {
				if (board[row][col] != null) {
					if (newBoard[row][col].type().equals("Pawn") && 
							newBoard[row][col].player() == Player.WHITE) {
						tempBoard[row][col] = new Pawn(Player.WHITE);
					} else if (newBoard[row][col].type().equals("Pawn"))
						tempBoard[row][col] = new Pawn(Player.BLACK);
					if (newBoard[row][col].type().equals("Rook") && 
							newBoard[row][col].player() == Player.WHITE) {
						tempBoard[row][col] = new Rook(Player.WHITE);
						if (!((Rook) board[row][col]).isCastlingValid())
							((Rook) tempBoard[row][col]).
							setCastlingValid(false);
					} else if (newBoard[row][col].type().equals("Rook")) {
						tempBoard[row][col] = new Rook(Player.BLACK);
						if (!((Rook) board[row][col]).isCastlingValid())
							((Rook) tempBoard[row][col]).
							setCastlingValid(false);
					}
					if (newBoard[row][col].type().equals("Bishop") && 
							newBoard[row][col].player() == Player.WHITE)
						tempBoard[row][col] = new Bishop(Player.WHITE);
					else if (newBoard[row][col].type().equals("Bishop"))
						tempBoard[row][col] = new Bishop(Player.BLACK);
					if (newBoard[row][col].type().equals("Knight") && 
							newBoard[row][col].player() == Player.WHITE)
						tempBoard[row][col] = new Knight(Player.WHITE);
					else if (newBoard[row][col].type().equals("Knight"))
						tempBoard[row][col] = new Knight(Player.BLACK);
					if (newBoard[row][col].type().equals("King") && 
							newBoard[row][col].player() == Player.WHITE) {
						tempBoard[row][col] = new King(Player.WHITE);
						if (!((King) board[row][col]).isCastlingValid())
							((King) tempBoard[row][col]).
							setCastlingValid(false);
					} else if (newBoard[row][col].type().equals("King")) {
						tempBoard[row][col] = new King(Player.BLACK);
						if (!((King) board[row][col]).isCastlingValid())
							((King) tempBoard[row][col]).
							setCastlingValid(false);
					}
					if (newBoard[row][col].type().equals("Queen") && 
							newBoard[row][col].player() == Player.WHITE)
						tempBoard[row][col] = new Queen(Player.WHITE);
					else if (newBoard[row][col].type().equals("Queen"))
						tempBoard[row][col] = new Queen(Player.BLACK);
				}
			}
	}

	/*************************************************************************
	 * @see IChessModel#currentPlayer()
	 ************************************************************************/
	public Player currentPlayer() {
		return player;
	}

	/*************************************************************************
	 * @return
	 ************************************************************************/
	public int numRows() {
		return BOARD_SIZE;
	}

	/*************************************************************************
	 * @return
	 ************************************************************************/
	public int numColumns() {
		return BOARD_SIZE;
	}

	/*************************************************************************
	 * @param row
	 * @param col
	 * @return
	 ************************************************************************/
	public IChessPiece pieceAt(int row, int col) {
		return board[row][col];
	}

	/*************************************************************************
	 * @return
	 ************************************************************************/
	public Move chessAIMove() {
		if (Player.BLACK == player) {

			duplicateBoard(board);

			int moveValue = 0;

			if (inCheck(Player.BLACK)) {
				for (int row = 0; row < BOARD_SIZE; row++)
					for (int col = 0; col < BOARD_SIZE; col++) {
						if (tempBoard[row][col] != null)
							if (tempBoard[row][col].player() == Player.BLACK){
								for (int r = 0; r < BOARD_SIZE; r++)
									for (int c = 0; c < BOARD_SIZE; c++) {
										Move temp = new Move(row, col, r, c);
										IChessPiece tempPiece = 
												tempBoard[row][col];
										IChessPiece tempPiece1 = null;
										if (tempBoard[r][c] != null)
											tempPiece1 = tempBoard[r][c];
										if (isValidMoveAI(temp)) {
											tempBoard[r][c] = tempPiece;
											tempBoard[row][col] = null;
											if (!tempBoardInCheck(
													Player.BLACK)) {
												tempBoard[row][col] = 
														tempPiece;
												tempBoard[r][c] = tempPiece1;
												return temp;
											}
										}
										tempBoard[row][col] = tempPiece;
										tempBoard[r][c] = tempPiece1;
									}
							}
					}
			}

			else {
				if (numMoves < 4) {
					for (int i = numMoves; i < randomMoves.size(); i++)
						if (isValidMoveAI(randomMoves.get(i))) {
							bestMove = randomMoves.get(i);
							lastMove = bestMove;
							numMoves++;
							return bestMove;
						}
				}
				else {
					for (int row = 0; row < BOARD_SIZE; row++)
						for (int col = 0; col < BOARD_SIZE; col++) {
							if (tempBoard[row][col] != null)
								if (tempBoard[row][col].player() == 
								Player.BLACK) {
									int temp = chessAI(tempBoard[row][col]); // send to chessAI
									if (temp >= moveValue) {
										moveValue = temp;
										if ( lastMove != possibleMove)
											bestMove = possibleMove;
									}
								}
						}
					lastMove = bestMove;
					return bestMove;
				}
			}
		}
		return null;
	}

	/*************************************************************************
	 * @param AIBoard
	 * @return
	 ************************************************************************/
	public int chessAI(IChessPiece AIBoard) {

		int moveValue = 0;
		int tempValue = 0;

		for (int row = 0; row < BOARD_SIZE; row++) {
			for (int col = 0; col < BOARD_SIZE; col++) {
				if (tempBoard[row][col] == AIBoard)
					for (int r = 0; r < BOARD_SIZE; r++) {
						for (int c = 0; c < BOARD_SIZE; c++) {
							if (r == lastMove.fromRow && c == 
									lastMove.fromColumn) 
								break;
							Move temp = new Move(row, col, r, c);
							if (isValidMoveAI(temp)) {
								if (tempBoard[r][c] != null && 
										tempBoard[r][c].type().equals("Pawn")
										&& tempBoard[row][col].type().
										equals("Pawn")) // if pawn to pawn make move 7
									moveValue = 7;
								else if (tempBoard[r][c] != null
										&& tempBoard[r][c].type().
										equals(tempBoard[row][col].type()))
									moveValue = AIBoard.getPieceWorth() * 2; // if same piece *2
								else if (tempBoard[r][c] != null)
									moveValue = AIBoard.getPieceWorth() + 
									tempBoard[r][c].getPieceWorth(); // random to random add them
								else
									moveValue = 1; // empty 'to' cell just make it 1
								if (moveValue > tempValue) {
									tempValue = moveValue;
									possibleMove = temp;
								}

								for (int rowW = 0; rowW < BOARD_SIZE; rowW++) {
									for (int colW = 0; colW < BOARD_SIZE; colW++) {
										if (tempBoard[rowW][colW] != null && tempBoard[rowW][colW].player() == Player.WHITE){
											Move tempW = new Move(rowW, colW, r, c);
											if (isValidMoveAI(tempW)) {
												if (tempBoard[row][col].type().equals("Queen")) // if pawn to pawn make move 7
													moveValue = moveValue/2;
												else if (tempBoard[row][col].type().equals(tempBoard[rowW][colW].type()))
													moveValue = moveValue - AIBoard.getPieceWorth(); // if same piece *2
												else if (tempBoard[row][col] != null)
													moveValue = moveValue - (AIBoard.getPieceWorth() + tempBoard[rowW][colW].getPieceWorth()); // random to random add them
												if (moveValue > tempValue) {
													tempValue = moveValue;
													possibleMove = temp;
												}
											}
										}
									}

								}
							}
						}
					}
			}
		}
		return tempValue;
	}

	/*************************************************************************
	 * @param move
	 * @return
	 ************************************************************************/
	public boolean castling(Move move) {

		duplicateBoard(board);

		if (!tempBoardInCheck(player)) {
			if (player == Player.WHITE) {
				if (tempBoard[move.fromRow][move.fromColumn].type().
						equals("King"))
					if (((King) tempBoard[move.fromRow][move.fromColumn]).
							isCastlingValid())
						if (move.toColumn == 2 && tempBoard[7][0] 
								instanceof Rook) {
							if (((Rook) tempBoard[7][0]).isCastlingValid())
								if (tempBoard[7][1] == null && tempBoard[7][2]
										== null && tempBoard[7][3] == null) {
									Move temp = new Move(7, 4, 7, 3);
									if (isValidMoveAI(temp)) {
										tempBoard[7][3] = tempBoard[7][4];
										tempBoard[7][4] = null;
										if (!tempBoardInCheck(Player.WHITE)) {
											Move temp1 = new Move(7, 3, 7, 2);
											if (isValidMoveAI(temp1)) {
												tempBoard[7][2] = 
														tempBoard[7][3];
												tempBoard[7][3] = null;
												if (!tempBoardInCheck(Player.
														WHITE)) {
													board[7][3] = 
															tempBoard[7][0];
													board[7][2] = 
															tempBoard[7][2];
													board[7][0] = null; // setting
													// rook
													// to
													// null
													board[7][4] = null; // setting
													// king
													// to
													// null
													player = player.next();
													return true;
												}
											}
										}
										tempBoard[7][4] = tempBoard[7][2];
										tempBoard[7][2] = null;
										tempBoard[7][0] = tempBoard[7][3];
										tempBoard[7][3] = null;
									}
								}
						} else if (move.toColumn == 6 && tempBoard[7][7] 
								instanceof Rook) {
							if (((Rook) tempBoard[7][7]).isCastlingValid())
								if (tempBoard[7][5] == null && tempBoard[7][6]
										== null) {
									Move temp = new Move(7, 4, 7, 5);
									if (isValidMoveAI(temp)) {
										tempBoard[7][5] = tempBoard[7][4];
										tempBoard[7][4] = null;
										if (!tempBoardInCheck(Player.WHITE)) {
											Move temp1 = new Move(7, 5, 7, 6);
											if (isValidMoveAI(temp1)) {
												tempBoard[7][6] = 
														tempBoard[7][5];
												tempBoard[7][5] = null;
												if (!tempBoardInCheck(Player.
														WHITE)) {

													board[7][5] = 
															tempBoard[7][7];
													board[7][6] = 
															tempBoard[7][6];
													board[7][7] = null; // setting
													// rook
													// to
													// null
													board[7][4] = null; // setting
													// king
													// to
													// null
													player = player.next();
													return true;
												}

											}
										}
										tempBoard[7][4] = tempBoard[7][6];
										tempBoard[7][6] = null;
										tempBoard[7][7] = board[7][5];
										tempBoard[7][5] = null;
									}
								}
						}
			} else if (tempBoard[move.fromRow][move.fromColumn].type().
					equals("King"))
				if (((King) tempBoard[move.fromRow][move.fromColumn]).
						isCastlingValid())
					if (move.toColumn == 2 && tempBoard[0][0] instanceof Rook)
					{
						if (((Rook) tempBoard[0][0]).isCastlingValid())
							if (tempBoard[0][1] == null && tempBoard[0][2] ==
							null && tempBoard[0][3] == null) {

								Move temp = new Move(0, 4, 0, 3);
								isValidMoveAI(temp);

								tempBoard[0][3] = tempBoard[0][4];
								tempBoard[0][4] = null;

								if (!tempBoardInCheck(Player.BLACK)) {

									Move temp1 = new Move(0, 3, 0, 2);
									isValidMoveAI(temp1);

									tempBoard[0][2] = tempBoard[0][3];
									tempBoard[0][3] = null;

									if (!tempBoardInCheck(Player.BLACK)) {

										board[0][3] = tempBoard[0][0];
										board[0][2] = tempBoard[0][2];
										board[0][0] = null; // setting rook to
										// null
										board[0][4] = null; // setting king to
										// null
										player = player.next();
										return true;
									}

								}
							}
						tempBoard[0][4] = tempBoard[0][2];
						tempBoard[0][2] = null;
						tempBoard[0][0] = board[0][3];
						tempBoard[0][3] = null;
					} else if (move.toColumn == 6 && tempBoard[0][7] 
							instanceof Rook) {
						if (((Rook) tempBoard[0][7]).isCastlingValid())
							if (tempBoard[0][5] == null && tempBoard[0][6] == 
							null) {

								Move temp = new Move(0, 4, 0, 5);
								isValidMoveAI(temp);

								tempBoard[0][5] = tempBoard[0][4];
								tempBoard[0][4] = null;

								if (!tempBoardInCheck(Player.BLACK)) {

									Move temp1 = new Move(0, 5, 0, 6);
									isValidMoveAI(temp1);

									tempBoard[0][6] = tempBoard[0][5];
									tempBoard[0][5] = null;

									if (!tempBoardInCheck(Player.BLACK)) {

										board[0][5] = tempBoard[0][7];
										board[0][6] = tempBoard[0][6];
										board[0][7] = null; // setting rook to
										// null
										board[0][4] = null; // setting king to
										// null
										player = player.next();
										return true;
									}
								}
							}
						tempBoard[0][4] = tempBoard[0][6];
						tempBoard[0][6] = null;
						tempBoard[0][7] = board[0][5];
						tempBoard[0][5] = null;
					}
		}

		return false;
	}

	/*************************************************************************
	 * @param move
	 * @return
	 ************************************************************************/
	public boolean isValidMoveAI(Move move) {

		if ((tempBoard[move.fromRow][move.fromColumn] != null))
			if (tempBoard[move.fromRow][move.fromColumn].isValidMove(move, 
					tempBoard))
				return true;

		return false;
	}

	/*************************************************************************
	 * @param move
	 * @return
	 ************************************************************************/
	public boolean highlight(Move move) {

		duplicateBoard(board);

		if ((tempBoard[move.fromRow][move.fromColumn] != null))
			if (tempBoard[move.fromRow][move.fromColumn].isValidMove(move, 
					tempBoard))
				return true;

		return false;
	}

	/*************************************************************************
	 * @param move
	 * @return
	 ************************************************************************/
	public boolean highlightRed(Move move) {

		duplicateBoard(board);

		tempBoard[move.toRow][move.toColumn] = 
				tempBoard[move.fromRow][move.fromColumn];
		tempBoard[move.fromRow][move.fromColumn] = null;

		for (int r = 0; r < BOARD_SIZE; r++)
			for (int c = 0; c < BOARD_SIZE; c++) {
				if (tempBoard[r][c] != null && tempBoard[r][c].player() != 
						currentPlayer()) {
					Move move1 = new Move(r, c, move.toRow, move.toColumn);
					if (isValidMoveAI(move1)) {
						// tempBoard[move.toRow][move.toColumn] =
						// tempBoard[r][c];
						return true;
					}
				}
			}
		return false;
	}

	/*************************************************************************
	 * @return
	 ************************************************************************/
	public Move getOutOfCheck() {

		for (int row = 0; row < BOARD_SIZE; row++)
			for (int col = 0; col < BOARD_SIZE; col++) {
				if (tempBoard[row][col] != null)
					if (tempBoard[row][col].player() != Player.BLACK) {
						for (int r = 0; r < BOARD_SIZE; r++)
							for (int c = 0; c < BOARD_SIZE; c++) {
								Move temp = new Move(row, col, r, c);
								if (isValidMoveAI(temp)) {
									tempBoard[r][c] = tempBoard[row][col];
									IChessPiece temp1 = tempBoard[row][col];
									tempBoard[row][col] = null;

									if (!inCheck(Player.BLACK)) {
										possibleMove = temp;
										tempBoard[r][c] = null;
										tempBoard[row][col] = temp1;
									}
								}

							}
					}
			}
		return possibleMove;
	}

}
